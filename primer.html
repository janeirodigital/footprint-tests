<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type"/>
    <title>Footprints Primer</title>
    <script async class="remove" src="//www.w3.org/Tools/respec/respec-w3c-common">
    </script>
    <script class="remove">
      var respecConfig = {
        shortName:      "footprints-spec",
        specStatus:     "ED",
        // specStatus:     "WG-NOTE",
        noRecTrack: true,
        edDraftURI:  "https://w3c.github.io/mynote/",
        editors:  [
          { name: "Eric Prud'hommeaux" , w3cid: "2112" }
        ],
        cg: "Solid",
        wgURI: "https://www.w3.org/community/solid/",
        // wgPatentURI:  "https://www.w3.org/2004/01/pp-impl/53154/status",
        github: {
          repoURL: "https://github.com/w3c/mynote/",
          branch: "master"
        },
      };
    </script>
    <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/default.min.css"/>
    <link rel="stylesheet" href="local.css"/>
    <style>
.cross::before { content: "(see spec)"; font-size: small; vertical-align: top; background-color: buttonface; display: none; }

/* draw tree per https://two-wrongs.com/draw-a-tree-structure-with-only-css */
.clt, .clt ul, .clt li {
     position: relative;
}

.clt ul {
    list-style: none;
    padding-left: 32px;
}
.clt li::before, .clt li::after {
    content: "";
    position: absolute;
    left: -12px;
}
.clt li::before {
    border-top: 1px solid #000;
    top: 9px;
    width: 8px;
    height: 0;
}
.clt li::after {
    border-left: 1px solid #000;
    height: 100%;
    width: 0px;
    top: 2px;
}
.clt ul > li:last-child::after {
    height: 8px;
}
    </style>
  </head>
  <body>

    <section id="abstract">
      <p>
        Semantic Web Applications interoperate by sharing semantics of terms and constellations of data structures.
        This primer introduces Footprints and describes how Semantic Web Applications use them to consistently interoperate over constellations of data structures.
      </p>
    </section>

    <section id="sotd">
      <p class="note">
        This document contains a lengthly problem statement, primer material and some more formal specification.
        We expect to separate these out into seperate documents but they are included in one place to make evaluation of this proposal easier for reviewers.
      </p>
      <p>
        This is a proposal for the structure and use of Footprints in Solid.
        It is possible that this or a derivative document will become a Solid specification.
      </p>
    </section>

    <section id="problem">
      <h2>Problem Statement</h2>
      <p>
        Solid allows information and media of all types to be stored, connected, and accessed by authorized entities and applications.
        Linked data allows this information to be self-identifying, which makes it immediately understandable by any application that knows how to interpret the linked data vocabularies and shapes in use.
      </p>
      <p>
        This relatively simple foundation establishes a basis for us to decouple data from applications.
        An individual who stores data in their pod should have the ability to use different applications to manipulate some or all of the same information, even if those applications were developed without any knowledge of each other.
        Solid affords us the opportunity to create a valuable and powerful ecosystem where entities retain control of their data, but are also able to put it to work and use it to its full potential.
        The fundamentals of Solid make this possible, but further definition of standard methods and conventions must be established to make it practical, intuitive, and secure.
      </p>
      <p>
        We must be able to support data interoperability across applications while enabling secure collaboration and query using intuitive data boundaries.
        Standard methods and conventions for organization, collaboration, and discovery of data in a Solid pod must realize these needs.
      </p>
      <section>
        <h3>Interoperability across applications</h3>
        <p>
          Unlike most applications people use today, data is not exclusive to any single application in Solid.
          Data in a Solid pod is meant to be read, written, and enriched by different applications in a seamlessly interoperable manner.
          This interoperability is achieved through the fulfillment of the following items:
        </p>
        <ul>
          <li>
            <dfn>Shared Definition of Data</dfn> &mdash; A common understanding between applications of the data being read and written is crucial.
            Solid’s linked data model provides this through shared vocabularies, and shape languages like ShEx and SHACL expand upon them by allowing us to create data models we can validate against.
          </li>
          <li>
            <dfn>Discoverability of Data</dfn> &mdash; Applications must know where to look for the data pertinent to them, and where to write the data they generate so that other applications can find and use it.
            In a decentralized data infrastructure, you cannot rely on data being in the same location from one store to another.
            Instead, there must be a mechanism for a client to discover where it can find the data it needs, and to be similarly informed of where to write it.
          </li>
          <li>
            <dfn>Durability of Data</dfn> &mdash; One application cannot break or corrupt the data being used by others.
            The hippocratic oath swears doctors to “first, do no harm”, and in similar fashion we must incorporate mechanics to prevent data corruption, either through accident or malicious intent.
          </li>
          <li>
            <dfn>Evolution of Data and Applications</dfn> &mdash; Data and Applications must have room to evolve independently without negatively affecting the other key tenets of interoperability, usability, and portability, or by violating secure data boundaries already in place.
          </li>
          <li>
            <dfn>Access and Manipulation by Different Entities</dfn> &mdash; Making data interoperable when one person is using multiple applications is challenging in its own right.
            This problem is compounded in Solid by the need to maintain data interoperability across applications that are operated by different entities.
            These entities may only be authorized to access or manipulate specific subsets of data, and are likely to have different needs that require different patterns of use.
          </li>
        </ul>
        <p>
          This diversity in how the same data will be accessed and manipulated exacerbates the need for reliable mechanisms that protect against data corruption or broken workflows.
          It also highlights the need for an intuitive way to define which subsets of data other entities can access.
        </p>
      </section>
      <section>
        <h3>Secure collaboration with intuitive data boundaries</h3>
        <p>
          In the most common use case, a Solid pod is controlled by one person; i.e. Alice.
          The data stored inside of that pod is Alice’s.
          As a controller of the pod, Alice has the ability to authorize others to access some or all of the data inside it.
        </p>
        <p>
          When deciding whether to authorize another entity (person, group, or application), to access data in her pod, Alice is faced with three considerations:
        </p>
        <ol>
          <li>Is this entity credible and trustworthy?</li>
          <li>What data should they be authorized to access?</li>
          <li>What level of access should they have?</li>
        </ol>
        <p><b>Is this entity credible and trustworthy?</b></p>
        <p>
          Determining whether an entity is credible or trustworthy is a complex and multi-faceted problem.
          It can require assurances as to the integrity of an individual, organization, or application at multiple levels, a problem which demands rigorous and dedicated focus.
          For the purposes of this initiative, we will consider this problem as directly relevant, but out of scope.
        </p>
        <p><b>What data should they be authorized to access?</b></p>
        <p>
          Alice must be equipped with the right amount of information, presented in an intuitive manner, to make safe decisions when she grants access to her data.
          She must prevent undue exposure to her data by giving out too much access, but at the same time she needs to provide enough to support the workflows that led her to share her data in the first place.
        </p>
        <p>
          Authorization must be intuitive
        </p>
        <p>
          Applications must be able to communicate the data they need access to
        </p>
        <p>
          People should understand the ramifications of what they are sharing.
        </p>
        <p>
          People should understand how the data will be used.
        </p>
        <p>
          People expect security, and also expect to not have to think about it
        </p>
        <p>
          People shouldn’t need to think about how things are stored if they don’t want to
        </p>
        <p>
          Things change and evolve, need a way to do this safely and smartly over time
        </p>
        <p>
          People think in terms of logical units of sharing or collaboration.
        </p>
        <p>
          Must avoid inadvertent access, where someone doesn’t realize what they’re giving access to
        </p>
        <p>
          Footprint interface should not betray server configuration (paths, other users...)
        </p>
        <p><b>What level of access should they have?</b></p>
        <p class="issue">
          E.g. Should they be able to read vs. write?
          What is a good scenario where access should be read only vs. write?
          Perhaps when sharing activity data.
          I want them to know how many steps I took, but I don’t expect them to change the values.
          As opposed to a wearable that is pushing the data who needs write access.
        </p>
      </section>
      <section>
        <h3>Robust query support</h3>
        <p>
          Data must be available for simple lookups and complex queries
        </p>
        <p>
          Organized correctly, we can facilitate rich lookups while maintaining strong and logical authorization boundaries
        </p>
        <p>
          Done correctly, we can ultimately support the evolution of data and applications by allowing queries to illustrate the shape of data they need, and furnishing that based on similar models available in the data set.
        </p>
        <p>
          Scope of this document will not be to design such a query infrastructure, but simply to ensure that such a query infrastructure can be supported by the design herein.
        </p>
      </section>
    </section>

    <section id="introduction">
      <h2>Introduction</h2>
      <p>
        RDF provides an infrastructure that allows for interoperability without specifically requiring it.
        Application interoperability depends on applications sharing semantics for relationships and data structures.
        Within a single resource, shapes languages (e.g. ShEx and SHACL) provide machine-readable, enforceable data structure definitions.
        For applications which exploit constellations of resources, Footprints express the layout of those resources and associate them with their respective shapes.
      </p>
      <p>
        A Footprint defines a tree of related resources which combine to enable some task.
        The footprint associates each resource with a shape in a schema.
        This document describes the structure and use of Footprints using three example tasks:
      </p>
      <ul>
        <li><b>PhotoAlbum</b> - collects photos or references to photos into sharable albums (<a href="https://github.com/janeirodigital/footprint-tests/blob/master/solidApps/staticRoot/album/PhotoAlbumFootprint.ttl">footprint</a>, <a href="https://github.com/janeirodigital/footprint-tests/blob/master/solidApps/staticRoot/album/PhotoAlbum.shex">schema</a>).</li>
        <li><b>MultiCal</b> - migrates calendar applications between two common formats, "Common" (<a href="https://github.com/janeirodigital/footprint-tests/blob/master/solidApps/staticRoot/cal/CalendarFootprint.ttl">footprint</a>, <a href="https://github.com/janeirodigital/footprint-tests/blob/master/solidApps/staticRoot/cal/Calendar.shex">schema</a>), and "Google" (<a href="https://github.com/janeirodigital/footprint-tests/blob/master/solidApps/staticRoot/cal/GoogleFootprint.ttl">footprint</a>, <a href="https://github.com/janeirodigital/footprint-tests/blob/master/solidApps/staticRoot/cal/GoogleCalendar.shex">schema</a>).</li>
        <li><b>GitHub</b> - a storage repository associating users or groups with repositories, issues and events (<a href="https://github.com/janeirodigital/footprint-tests/blob/master/solidApps/staticRoot/gh/ghFootprint.ttl">footprint</a>, <a href="https://github.com/janeirodigital/footprint-tests/blob/master/solidApps/staticRoot/gh/ghSchema.shex">schema</a>).</li>
      </ul>
      <p>
        Each of the above footprints is available in Turtle or JSON-LD.
        You can change the <code>.ttl</code> extension to <code>.jsonld</code> to see the JSON-LD.
        The application directories described in this document are suffixed with "App" to make it easy to distinguish the App directory from the possibly similarly-named application and footprint.
      </p>
      <div class="issue">
      <p>
        Terminology Q: are "footprints" the resource trees in the POD or declarative descriptions thereof?
      </p>
      <p>
        Earlier discussions of "Footprints" imply that they describe how application data appears in a POD.
        These don&apos;t provide a name for an instantiation of that data in the POD.
        It might make more sense to have a shared "FootprintDescription" which describes the instantiations which would be called "Footprints".
        As it stands, we have a collection of related-sounding terms ("footprint", "step", "path") but our real-world intuitions about their interrelationships don&apos;t apply to their use in this spec.
        Also, the spec and primer say "instance" over and over again.
      </p>
      </div>
    </section>

    <section id="structure">
      <h2>Footprint Structure <a class="cross" href="spec#structure"></a></h2>
      <p>
        A footprint is a tree structure of <dfn>steps</dfn> which in turn describes a tree structure of Resources (effectively a hierarchy of directories and files).
        Each file or directory is described by <a>step</a>.
        A step consists of:
      </p>
      <ul>
        <li>an optional <dfn>id</dfn>: an addressable label for this step.</li>
        <li>a <dfn>type</dfn>: LDP type of the associated resource: <code>BasicContainer</code>, <code>IndirectContainer</code> OR <code>Resource</code>.</li>
        <li style="list-style: none;">
        <ul>
          <li>either a <dfn>label</dfn>: label for a resource which will always be created.<br/>
          or a</li>
          <li>or a <dfn>uriTemplate</dfn>: pattern for a resource to be matched against a POSTed Slug: header <a class="excode" href="https://github.com/janeirodigital/footprint-tests/blob/master/util/footprint.js#L280-L297"></a>, . <span class="issue">could use a Link: header instead</span></li>
        </ul>
        </li>
        <li>a <dfn>shape</dfn>: RDF graph structure of to which any POSTed or PUT resource must conform.</li>
        <li>an optional <dfn>contents</dfn>: a list of nested steps.</li>
      </ul>
      <p>
        The outer-most step must have an <a>id</a>, has neither a <a>label</a> nor a <a>uriTemplate</a> and has at least one <a>contents</a> arc.
        The PhotoApp has a simple Footprint <a class="excode" href="https://github.com/janeirodigital/footprint-tests/blob/master/solidApps/staticRoot/photo/PhotoFootprint.jsonld"></a>:
      </p>
      <div>
        <pre><code class="json">
{ "@id": "#root", "type":"ldp:BasicContainer", "contents":[
  { "@id": "#image",
    "type": "ldp:BinaryResource",
    "uriTemplate": "{entryName}",
    "shape": "Photo#Photo"
  }
] }</code></pre>
      </div>
      <p>
        The PhotoAlbumApp&apos;s Footprint <a class="excode" href="https://github.com/janeirodigital/footprint-tests/blob/master/solidApps/staticRoot/album/PhotoAlbumFootprint.jsonld"></a> uses uriTemplates to discriminate between different types of Resource.
        The top Container holds both images and references.
        They are distinguised by their name, either "img-..." or "ref-...".
        Any entry which is POSTed to the Container must have a Slug: header which matches one of the <a>uriTemplates</a>.
        That match determines the shape for validation and the metadata that the POD will store about the new-created Container member:
      </p>
      <div>
        <pre><code class="json">
{ "@id": "#root", "type": "ldp:BasicContainer", "contents": [
  { "@id": "#img-ref", "type": "ldp:Resource",
    "uriTemplate": "ref-{entryNo}", "shape": "PhotoAlbum#PhotoReference" },
  { "@id":  "#image", "type": "ldp:BinaryResource",
    "uriTemplate": "img-{entryNo}"}
] }
</code></pre>
      </div>
      <p>
        For an example of a complex Footprint, the GitApp has a deeply-nested Footprint <a class="excode" href="https://github.com/janeirodigital/footprint-tests/blob/master/solidApps/staticRoot/gh/ghFootprint.jsonld"></a>.
      </p>
      <!-- div>
        <pre><code class="json">
{ "@id": "#root",
  "type": "ldp:BasicContainer", "contents": [
  { "@id": "#repos", "type": "ldp:BasicContainer",
    "name": "repos" , "contents":[
    { "@id": "#org", "type": "ldp:BasicContainer",
      "uriTemplate": "{orgName}", "shape": "ghSchema#PersonShape", "contents": [
      { "@id": "#repo", "type": "ldp:BasicContainer",
        "uriTemplate": "{repoName}", "shape": "ghSchema#RepoShape", "contents": [
      ...
      ]}
    ]}
  ]},
  { "@id": "#users", "type": "ldp:BasicContainer",
    "name": "users", "contents": [
    { "@id": "#user", "type": "ldp:BasicContainer",
      "uriTemplate": "{userName}", "shape": "ghSchema#PersonShape", "contents": [
      { "@id": "#followers", "type": "ldp:IndirectContainer",
        "name":"followers", "shape": "ghSchema#C_UserShape", "contents": [
        { "@id": "#follower", "type":"ldp:Resource",
          "uriTemplate":"{userName}", "shape": "ghSchema#PersonShape" }
      ]},
      ...
    ]}
  ]}
] }
        </code></pre>
      </div -->
    <section id="structure">
      <h3>Formal Representation of Structure <a class="cross" href="primer#structure"></a></h3>
      <p>
        A <dfn>Footprint</dfn> is a machine-readable template describing the expected layout of a tree of LDP Resources in a POD.
        The Footprint structure is a tree that can be expressed in JSON-LD as nested JSON objects or as a hierarchical RDF graph.
        It is composed of a set of steps in hierarchy captured by <code>foot:contents</code> links:
      </p>
      <div>
        <pre><code class="shexc">
&lt;#Step&gt; CLOSED {
  foot:instanceType [ldp:BasicContainer ldp:IndirectContainer ldp:Resource] ;
  (rdfs:label xsd:string | foot:uriTemplate xsd:string) ;
  foot:shape IRI ? ;
  foot:contents @&lt;#Step&gt;*
}
        </code></pre>
      </div>
      <p>
        The <code>foot:contents</code> property MUST NOT introduce any cycles into the RDF graph.
      </p>
      <p>
        The realization of a <a>footprint</a> is an <dfn>instance tree</dfn>.
        The the upper-most Container of that tree is an <dfn>instance root</dfn>.
        Let <code>F</code> be a <a>footprint</a>; lket <code>T</code> be a corresponding <a>instance tree</a><!-- ; let <code>R</code> be its <a>instance root</a> -->.
        For any step <code>S</code> in <code>F</code>:
      </p>
      <ul>
        <li>The rdf:type arc (written 'a' above) identifies the type of a corresponding Resource <code>R</code> in <code>T</code>.</li>
        <li>An { <code>S</code> <code>rdfs:label</code> <code>L</code> } arc indicates that there is exactly one corresponding Resource <code>R</code> and it has the name <code>L</code>.</li>
        <li>An { <code>S</code> <code>foot:uriTemplate</code> <code>L</code> } arc indicates that there are an arbitrary number of corresponding Resources <code>R</code> and each will have a name that matches the URI template [[RFC6570]] <code>L</code>.</li>
        <li>An { <code>S</code> <code>foot:shape</code> <code>Sh</code> } arc indicates that <code>R</code> must have exactly one node which conforms to <code>Sh</code>.</li>
        <li>Any { <code>S</code> <code>foot:contents</code> <code>S2</code> } arcs indicate there is a nested step and corresponding nested Resource <code>R2</code>.
        <div class="issue">
          <p>
            The shape above could be more precise, allowing only for <code>foot:contents</code> arcs if the type is a Container:
          </p>
          <pre><code class="shexc">
&lt;#Step&gt; CLOSED {
  (
    a [ldp:BasicContainer ldp:IndirectContainer] ;
    (rdfs:label xsd:string | foot:uriTemplate xsd:string) ;
    foot:contents @&lt;#Step&gt; +
  |
    a [ldp:Resource] ;
    foot:uriTemplate xsd:string
  ) ;
  foot:shape IRI ? ;
}
          </code></pre>
          <p>Is that too geeky?</p>
        </div>
        </li>
      </ul>
    </section>
    </section>

    <section id="ecosystem">
      <h2>Ecosystem</h2>
      <p>
        Footprints can enable compatible applications to interoperate by identifying resources they can share.
        Conventions for indexing footprints and storing application metadata allow applications to find interoperable data and identify the applications that depend on or manipulate that data.
        While many possible such conventions would work, this one was chosen for predictability, simplicity and familiarity to users:
      </p>

      <section id="layout">
        <h2>Resource Layout</h2>
        <p>
          The "Resource Layout" can be thought of like a filesystem layout; it is the hierarchy implied by the path components of Resource URLs.
          Footprints enable interoperability of applications installed following this convention <a class="excode" href="https://github.com/janeirodigital/footprint-tests-output#file-tree"></a>:
        </p>
        <div class="clt">
          / &nbsp; <span class="issue">it&apos;s 2020, why is it still a pain to draw a @#%$ing tree?</span>
          <ul>
            <li>
              Apps
              <ul>
                <li>
                  PhotoAlbumApp
                  <ul>
                    <li>Protected</li>
                    <li>Private</li>
                  </ul>
                </li>
                <li>
                  MultiCalApp
                  <ul>
                    <li>Protected</li>
                    <li>Private</li>
                  </ul>
                </li>
                <li>
                  GhApp
                  <ul>
                    <li>Protected</li>
                    <li>Private</li>
                  </ul>
                </li>
              </ul>
            </li>
            <li id="Share">
              Share
              <ul>
                <li>Albums -- stomped by PhotoAlbumApp</li>
                <li>Calendar -- stomped by MutliCalApp</li>
                <li>Google -- stomped by MultiCalApp</li>
                <li>ghInstance -- stomped by GhApp</li>
              </ul>
            </li>
          </ul>
        </div>
      </section>

      <section id="discovery">
        <h3>Discovery</h3>
        <p>
          When an application needs to work with a particular Footprint, it can GET the <code>/Share/</code> Container and search for child Containers with a <code>foot:footprintRoot</code> of the desired Container.
          Many applications will need only one Footprint but some will work with two ore more Footprints.
          For instance, MultiCal requires a common calendar footprint and a google calendar footprint <a class="excode" href="https://github.com/janeirodigital/footprint-tests/blob/master/test/cal.test.js#L40-L57"></a>.
          <span class="issue">Permissions will be subject to the outcome of <a href="https://github.com/solid/specification/issues/116">#116</a>.</span>
        </p>
        <p>
          GET <code>/Share/</code> will return a triples identifying the shared Containers with that footprint:
        </p>
        <pre>{<code class="turtle nohighlight">&lt;Calendar/&gt; foot:footprintRoot &lt;.../CalendarFootprint#calendar&gt; .</code>}</pre>
        <p>
          The application may then GET <code class="turtle nohighlight">&lt;Calendar/&gt;</code> to determine form e.g. the ACLs ore the metadata in the Container whether this is the instance of that footprint.
        </p>
      </section>
    </section>

    <section id="stomp">
      <h2>Stomping a Footprint <!-- a class="cross" href="spec#stomp"></a --></h2>
      <p>
        When an application doesn&apos;t find a desired footprint appropriate for its use, it must ask the POD to allocate the ldp:Containers defined in the footprint.
        This is done with a <b>STOMP</b> operation, a POST to the parent Container with a <code>rel="footprint"</code> Link header <a class="excode" href="https://github.com/janeirodigital/footprint-tests/blob/master/test/test-harness.js#L63-L69"></a>.
        The MultiCal application may know that it has permissions to create Containers in the POD&apos;s <code>/Shared</code> Container.
        It would request the POD to create a <code>Calendar</code> Container associated with the "CommonCalendar" application:
      </p>
      <div class="example">
        <p><a href="https://github.com/janeirodigital/footprint-tests/blob/master/test/cal.test.js#L47-L48">associated test</a></p>
        <pre class="http nohighlight"><code>
POST /Shared/
Slug: Calendar
Link: &lt;http://www.w3.org/ns/ldp#Container&gt;; rel="type"
Link: <a href="https://github.com/janeirodigital/footprint-tests/blob/master/solidApps/staticRoot/cal/CalendarFootprint.jsonld">http://.../cal/CalendarFootprint#calendar</a>; rel="footprint"
        </code></pre>
      </div>
      <p>
        The footprint will identify one or more Containers into which the application may store Resources.
        The Calendar application&apos;s footprint starts from the <code>#calendar</code> node, which happens to be the JSON root in this JSON-LD expression of the footprint:
      </p>
      <div>
        <pre><code class="example footprint js">
{ "@context": { ... },
  "@id": "#calendar",
  "type":"ldp:BasicContainer",
  "shape": "Calendar#Calendar",
  "contents":[
    { "@id": "#appointment",
      "type":"ldp:Resource",
      "uriTemplate":"{appointmentNo}",
      "shape": "Calendar#Appointment" }
] }
        </code></pre></div>

      <section id="stomped-image">
        <h3>Stomped Image on POD</h3>
        <p>
          When an client application STOMPs a footprint <a class="excode" href="https://github.com/janeirodigital/footprint-tests/blob/master/ldpServer.js#L47-L78"></a>, the POD will <!-- record the association between the create a an <code>instantiation</code> of tha.
          This defines -->
        </p>
        <ul>
          <li>Create a Container for that Footprint instance (the name of which might respect the Slug: header).
          <ul>
          <li>Create any sub-Containers which have <code>rdfs:label</code>s in the Footprint.
          For instance, the GitHub Footprint <a href="https://github.com/janeirodigital/footprint-tests/blob/master/solidApps/staticRoot/gh/ghFootprint.ttl#L6">has the nested Containers "repos" and "users"</a> and they in turn have no <code>foot:Contents</code> with <code>rdfs:label</code>s.
          </li>
          </ul>
          <pre><code class="example footprint js">
{ "@context": ...,
  "@id": "#root",
  "type": "ldp:BasicContainer", "contents": [
    {
      "@id": "#repos",
      "type": "ldp:BasicContainer",
      "name": "repos",
      "contents": [
        ...
      ]
    },
    {
      "@id": "#users",
      "type": "ldp:BasicContainer",
      "name": "users",
      "contents": [
        ...
      ] }
  ] }
          </code></pre>
          </li>
          <li>Add a <code>foot:footprintRoot</code> association in the parent Container (typically, <code>/Share/</code>):
          <pre>{<code class="turtle nohighlight">&lt;Calendar/&gt; foot:footprintRoot &lt;.../CalendarFootprint#calendar&gt; .</code>}</pre>
          </li>
          <li>Create and populate an Application Container underneath <code>/Apps/</code>. An application which has installed Footprints in multiple Containers will have multiple instantiations:
          <pre><code class="example turtle">
&lt;//store.example/MultiCalApp&gt; foot:name "MultiCalApp".
&lt;&gt; foot:installedIn _:b1, _:b3.

_:b1 foot:app &lt;//store.example/MultiCalApp&gt;;
    foot:footprintRoot &lt;//localhost:35005/cal/CalendarFootprint#calendar&gt;;
    foot:footprintInstancePath "www/Shared/Calendar";
    foot:instantiationDateTime "2020-01-16T10:16:26.887Z"^^xsd:dateTime.

# a second installation of MultiCal
_:b3 foot:app &lt;//store.example/MultiCalApp&gt;;
    foot:footprintRoot &lt;//localhost:35005/cal/GoogleFootprint#top&gt;;
    foot:footprintInstancePath "www/Shared/Google";
    foot:instantiationDateTime "2020-01-16T10:16:26.911Z"^^xsd:dateTime.
          </code></pre>
          </li>
        </ul>
        <p class="issue">
          Index location: currently stored <a class="excode" href="https://github.com/janeirodigital/footprint-tests/blob/master/ldpServer.js#L71"></a> and searched for <a class="excode" href="https://github.com/janeirodigital/footprint-tests/blob/master/ldpServer.js#L48"></a> in the parent directory.
          This makes sense for a monolithic <code>/Apps</code> directory but creates islands of searchability if footprints are registered in arbitrary locations (e.g. with multiple <code>/Apps</code>-like Containers for different app stores).
        </p>
        <p class="issue">
          It&apos;s likely that we want to let the client decide when to re-use an existing footprint (i.e. reuse <a href="#discovery">discovery</a>), but it&apos;s possible to have the POD reuse an existing footprint <a class="excode" href="https://github.com/janeirodigital/footprint-tests/blob/master/ldpServer.js#L50-L60"></a> and retrun a 304 (no body allowed on a 304).
        </p>
      </section>

      <section id="stomp">
        <h3>Multi-Footprint Applications</h3>
        <p>
          Because MultiCal is a gateway between multiple event formats, it registers a second footprint:
        </p>
        <div class="example">
          <p><a href="https://github.com/janeirodigital/footprint-tests/blob/master/test/cal.test.js#L56-L57">associated test</a></p>
          <pre class="http nohighlight"><code>
POST /Shared/
Slug: Google
Link: &lt;http://www.w3.org/ns/ldp#Container&gt;; rel="type"
Link: <a href="https://github.com/janeirodigital/footprint-tests/blob/master/solidApps/staticRoot/cal/GoogleFootprint.jsonld">http://.../cal/GoogleFootprint#top</a>; rel="footprint"
          </code></pre>
        </div>
        <p>
          This footprint provisions a nested container called <code>Events</code> and specifies that every event in that container conform to the <code>&lt;EventShape&gt;</code>.
        </p>
        <div class="">
          <pre><code class="example footprint js">
{ "@context": { ... },

  "@id": "#top",
  "type": "ldp:BasicContainer" ,
  "contents": [
    { "@id": "#Events",
      "type": "ldp:BasicContainer" ,
      "name": "Events",
      "contents": [
        { "@id": "#Event",
          "type": "ldp:Resource",
          "uriTemplate": "{EventName}",
          "shape": "GoogleCalendar#EventShape" }
    ] }
] }
          </code></pre>
        </div>
      </section>
    </section>

    <section id="post-managed">
      <h2>Posting to Managed Containers <a class="cross" href="spec#post-managed"></a></h2>
      <p>
        When POSTing to any Managed Container, there will be a corresponding step in the Footprint.
        If the step includes a shape, the POST must include a Link: rel="root" header to identify the node in the POSTed data that should conform to that shape.        
      </p>
      <p>
        When receiving a POST to a managed resource, an application POSTs to a Managed Container, the POD locates the corresponding step in the Footprint.
        If the step includes a shape, the POST body is parsed and the root node is tested for conformance.
        If it&apos;s invalid, the requested with a 422 Unprocessable Entity message.
        If it&apos;s valid or has no associated shape, the typical LDP processing will create an entity whose contents include the POSTed body.
      </p>
      <p>If processing produces no errors, the POD will again Create any sub-Containers which have <code>rdfs:label</code>s in the Footprint.
      For instance, the <a href="https://github.com/janeirodigital/footprint-tests/blob/master/solidApps/staticRoot/gh/ghFootprint.ttl#L21">GitHub Footprint step for {userName}</a> has a nested Containers <code>Subscriptions</code>s (and many others).
      </p>
      <pre><code class="example footprint js">
{ "@id": "#root",
  "type":"ldp:BasicContainer", "contents":[
    ... ,
    { "type": "ldp:BasicContainer", "name":"users",
      "contents": [
        { "type":"ldp:BasicContainer", "uriTemplate":"{userName}",
          "shape": "ghSchema#PersonShape",
          "contents": [
            { "type":"ldp:IndirectContainer", "name":"subscriptions",
              "shape": "ghSchema#C_SubscrShape",
              "contents": [
                { "type":"ldp:Resource", "uriTemplate":"{subscriptName}",
                  "shape": "ghSchema#SubscrShape" }
              ]}
          ]}
      ]}
  ]}
      </code></pre>
    </section>


    <script src="http://www.w3.org/2019/Talks/1209-swat4ls-egp/highlight.pack.js"></script>
    <script src="http://www.w3.org/2019/Talks/1209-swat4ls-egp/highlight-shexc.js"></script>
    <!-- <script src="WWW/2019/Talks/1209-swat4ls-egp/highlight-shexc.js"></script> -->
    <script>
      // TODO: add ShEx highlighter to respec
      hljs.registerLanguage('shexc', hljsDefineShExC);
      hljs.registerLanguage('turtle', hljsDefineTExpr);
      (['DOMContentLoaded', 'load']).forEach(e => addEventListener(e, init, false));
      let inited = false;

      function hljsDefineTExpr (highlightjs) { // works pretty well for Turtle.
        const ret = hljsDefineShExC(highlightjs, 'tripleConstraint');
        ret.disableAutodetect = true;
        return ret;
      }

      function init () {
        if (inited) return;
        inited = true;
        ([400, 800, 1600]).forEach(
          tOut => setTimeout(highlightAll, tOut)
        )
      }

      function highlightAll () {
        console.log(new Date())
        try {
          const blocks = document.querySelectorAll('.shexc,.turtle');
          [].forEach.call(blocks, (b) => {
            hljs.highlightBlock(b);
          });
        } catch (e) {}
      }
    </script>
  </body>
</html>
